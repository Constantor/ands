<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>ands.ds.MinHeap API documentation</title>
    <meta name="description" content="Author: Nelson Brochado

Creation: July, 2015

Last update: 13/02/16

A binary min heap is a data st..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#ands.ds.MinHeap.MinHeap">MinHeap</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.__init__">__init__</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.add">add</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.clear">clear</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.contains">contains</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.find_min">find_min</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.get">get</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.get_left_child_index">get_left_child_index</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.get_parent_index">get_parent_index</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.get_right_child_index">get_right_child_index</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.heapify">heapify</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.is_empty">is_empty</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.is_good_index">is_good_index</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.merge">merge</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.push_down">push_down</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.push_up">push_up</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.remove">remove</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.remove_min">remove_min</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.replace">replace</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.search">search</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.search_by_value">search_by_value</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.show">show</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.size">size</a></li>
    <li class="mono"><a href="#ands.ds.MinHeap.MinHeap.swap">swap</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">ands.ds.MinHeap</span> module</h1>
  <p>Author: Nelson Brochado</p>
<p>Creation: July, 2015</p>
<p>Last update: 13/02/16</p>
<p>A binary min heap is a data structure similar to a binary tree,
where the parent nodes are smaller or equal to their children.</p>
<p>In addition to the previous constraint, a binary min heap is a complete binary tree,
that is, all levels of the tree, except possibly the deepest one are fully filled,
and, if the last level of the tree is not complete,
the nodes of that level are filled from left to right.</p>
<p>A min heap can be implemented with a classic array or list in Python.</p>
<p>If we have a node at index i, then</p>
<ul>
<li>
<p>its left child can be found at index i*2 + 1</p>
</li>
<li>
<p>its right child is found at i*2 + 2,</p>
</li>
<li>
<p>its parent can be found at index floor((i - 1) / 2),
where floor(x) truncates x to the smallest integer.</p>
</li>
</ul>
<p>Note that these indexes are for 0-index based lists (or arrays).</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap" class="source">
    <pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Author: Nelson Brochado

Creation: July, 2015

Last update: 13/02/16

A binary min heap is a data structure similar to a binary tree,
where the parent nodes are smaller or equal to their children.

In addition to the previous constraint, a binary min heap is a complete binary tree,
that is, all levels of the tree, except possibly the deepest one are fully filled,
and, if the last level of the tree is not complete,
the nodes of that level are filled from left to right.

A min heap can be implemented with a classic array or list in Python.

If we have a node at index i, then

- its left child can be found at index i*2 + 1

- its right child is found at i*2 + 2,

- its parent can be found at index floor((i - 1) / 2),
where floor(x) truncates x to the smallest integer.

Note that these indexes are for 0-index based lists (or arrays).
"""

from ands.ds.Heap import Heap
from ands.ds.HeapNode import HeapNode


class MinHeap(Heap):

    def __init__(self, ls=[]):
        Heap.__init__(self)
        self.heap = self._create_list_of_heap_nodes(ls)
        self._build_min_heap()

    def _build_min_heap(self):
        """Creates a min heap using the list passed to the constructor.

        Note that in a heap A all nodes from A[n/2 + 1] to A[n] are leaf nodes.

        **Time Complexity:** O(n)."""
        for index in range(len(self.heap) // 2, -1, -1):
            self.heapify(index)
        return self.heap

    def heapify(self, i: int):
        """Min-heapify this mean heap starting from index `i`.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        _min = i
        left = Heap.get_left_child_index(self.heap, i)
        right = Heap.get_right_child_index(self.heap, i)

        if left and self.heap[left] < self.heap[_min]:
            _min = left

        if right and self.heap[right] < self.heap[_min]:
            _min = right

        # One of the children of ls[i] was smaller than ls[i],
        # and we need to swap ls[i] with its smallest child ls[m].
        if _min != i:
            self.swap(_min, i)
            self.heapify(_min)

        return _min

    def add(self, heap_node: HeapNode):
        """Adds a `heap_node` to this heap.

        **Time Complexity:** O(log<sub>2</sub> n)."""

        # Sets the current index of heap_node.
        # This index could change by a "push up" operation.
        heap_node.index = self.size()
        self.heap.append(heap_node)

        if self.size() > 1:
            self.push_up(self.size() - 1)

    def find_min(self):
        """Returns (without removing) the smallest element in the heap.

        **Time Complexity:** O(1)."""
        if not self.is_empty():
            return self.heap[0]

    def remove_min(self):
        """Removes and returns the smallest element in this heap.

        **Time Complexity:** O(log<sub>2</sub> n),
        unless the list's pop operation is linear
        also when popping the last element,
        which would make this algorithm to have a time complexity O(n)."""
        if not self.is_empty():
            self.swap(0, self.size() - 1)
            min_element = self.heap.pop()
            
            if not self.is_empty():
                self.push_down(0)
                
            return min_element

    def push_down(self, i: int):
        """Calls self.heapify(i)."""
        self.heapify(i)

    def push_up(self, i):
        """Pushes up the heap the node at index i.

        Note that this operation only happens
        if the node at index i is smaller than its parent.

        This function is simpler than push_down or heapify,
        because in this case we just need to compare
        the current node's index with its parent's index.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        current_index = i
        p = MinHeap.get_parent_index(self.heap, i)

        # We need specifically to check if p is not None,
        # because it could be 0,
        # and the following if statement would not be executed (wrongly).
        if p is not None and self.heap[current_index] < self.heap[p]:
            current_index = p
            
        if current_index != i:
            self.swap(current_index, i)
            self.push_up(current_index)

    def search(self, heap_node: HeapNode):
        """Searches for heap_node in this heap,
        and if present, returns its index, otherwise returns -1.

        **Time Complexity:** O(n)."""
        for i, node in enumerate(self.heap):
            if node == heap_node:
                return i
        return -1

    def contains(self, heap_node: HeapNode):
        """Returns True, if heap_node is in the heaps.

        **Time Complexity:** O(n)."""
        return self.search(heap_node) != -1

    def search_by_value(self, value: object):
        """Returns the index of the HeapNode with value=value.
        -1 is returned if no such a HeapNode exists.

        **Time Complexity:** O(n)."""
        for i, node in enumerate(self.heap):
            if node.value == value:
                return i
        return -1

    def merge(self, other_heap: Heap):
        """Merges this heap with `other_heap`."""
        self.heap += other_heap.get()

        def _merge_aux():
            """Updates the indices of all `HeapNode` objects."""
            for i, heap_node in enumerate(self.heap):
                heap_node.index = i

        _merge_aux()
        return self._build_min_heap()

    def swap(self, i: int, j: int):
        """Swaps `HeapNode` objects at indexes `i` and `j`,
        and updates their new index field's value.

        **Time Complexity:** O(1)."""
        self.is_good_index(self.heap, i)
        self.is_good_index(self.heap, j)

        # Updates the index field of each HeapNode.
        # This is useful for example when search for a Node's position
        # which can then be done therefore in constant time.
        self.heap[i].index = j
        self.heap[j].index = i

        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]

    def replace(self, i: int, new_heap_node: HeapNode):
        """Replaces element at index `i` with `new_heap_node`.

        1. If `new_heap_node == self.heap[i]`,
        then just replace `self.heap[i]` with `new_heap_node`.

        2. Else if `new_heap_node < self.heap[i]`,
        then push_up(index).

        3. Else `new_heap_node > self.heap[i]`,
        then call `self.heapify(i)`.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        self.is_good_index(self.heap, i)

        current_node = self.heap[i]
        new_heap_node.index = current_node.index

        self.heap[i] = new_heap_node

        if new_heap_node > current_node:
            self.push_down(i)

        elif new_heap_node < current_node:
            self.push_up(i)
            
        return current_node
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="ands.ds.MinHeap.MinHeap" class="name">class <span class="ident">MinHeap</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap" class="source">
    <pre><code>class MinHeap(Heap):

    def __init__(self, ls=[]):
        Heap.__init__(self)
        self.heap = self._create_list_of_heap_nodes(ls)
        self._build_min_heap()

    def _build_min_heap(self):
        """Creates a min heap using the list passed to the constructor.

        Note that in a heap A all nodes from A[n/2 + 1] to A[n] are leaf nodes.

        **Time Complexity:** O(n)."""
        for index in range(len(self.heap) // 2, -1, -1):
            self.heapify(index)
        return self.heap

    def heapify(self, i: int):
        """Min-heapify this mean heap starting from index `i`.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        _min = i
        left = Heap.get_left_child_index(self.heap, i)
        right = Heap.get_right_child_index(self.heap, i)

        if left and self.heap[left] < self.heap[_min]:
            _min = left

        if right and self.heap[right] < self.heap[_min]:
            _min = right

        # One of the children of ls[i] was smaller than ls[i],
        # and we need to swap ls[i] with its smallest child ls[m].
        if _min != i:
            self.swap(_min, i)
            self.heapify(_min)

        return _min

    def add(self, heap_node: HeapNode):
        """Adds a `heap_node` to this heap.

        **Time Complexity:** O(log<sub>2</sub> n)."""

        # Sets the current index of heap_node.
        # This index could change by a "push up" operation.
        heap_node.index = self.size()
        self.heap.append(heap_node)

        if self.size() > 1:
            self.push_up(self.size() - 1)

    def find_min(self):
        """Returns (without removing) the smallest element in the heap.

        **Time Complexity:** O(1)."""
        if not self.is_empty():
            return self.heap[0]

    def remove_min(self):
        """Removes and returns the smallest element in this heap.

        **Time Complexity:** O(log<sub>2</sub> n),
        unless the list's pop operation is linear
        also when popping the last element,
        which would make this algorithm to have a time complexity O(n)."""
        if not self.is_empty():
            self.swap(0, self.size() - 1)
            min_element = self.heap.pop()
            
            if not self.is_empty():
                self.push_down(0)
                
            return min_element

    def push_down(self, i: int):
        """Calls self.heapify(i)."""
        self.heapify(i)

    def push_up(self, i):
        """Pushes up the heap the node at index i.

        Note that this operation only happens
        if the node at index i is smaller than its parent.

        This function is simpler than push_down or heapify,
        because in this case we just need to compare
        the current node's index with its parent's index.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        current_index = i
        p = MinHeap.get_parent_index(self.heap, i)

        # We need specifically to check if p is not None,
        # because it could be 0,
        # and the following if statement would not be executed (wrongly).
        if p is not None and self.heap[current_index] < self.heap[p]:
            current_index = p
            
        if current_index != i:
            self.swap(current_index, i)
            self.push_up(current_index)

    def search(self, heap_node: HeapNode):
        """Searches for heap_node in this heap,
        and if present, returns its index, otherwise returns -1.

        **Time Complexity:** O(n)."""
        for i, node in enumerate(self.heap):
            if node == heap_node:
                return i
        return -1

    def contains(self, heap_node: HeapNode):
        """Returns True, if heap_node is in the heaps.

        **Time Complexity:** O(n)."""
        return self.search(heap_node) != -1

    def search_by_value(self, value: object):
        """Returns the index of the HeapNode with value=value.
        -1 is returned if no such a HeapNode exists.

        **Time Complexity:** O(n)."""
        for i, node in enumerate(self.heap):
            if node.value == value:
                return i
        return -1

    def merge(self, other_heap: Heap):
        """Merges this heap with `other_heap`."""
        self.heap += other_heap.get()

        def _merge_aux():
            """Updates the indices of all `HeapNode` objects."""
            for i, heap_node in enumerate(self.heap):
                heap_node.index = i

        _merge_aux()
        return self._build_min_heap()

    def swap(self, i: int, j: int):
        """Swaps `HeapNode` objects at indexes `i` and `j`,
        and updates their new index field's value.

        **Time Complexity:** O(1)."""
        self.is_good_index(self.heap, i)
        self.is_good_index(self.heap, j)

        # Updates the index field of each HeapNode.
        # This is useful for example when search for a Node's position
        # which can then be done therefore in constant time.
        self.heap[i].index = j
        self.heap[j].index = i

        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]

    def replace(self, i: int, new_heap_node: HeapNode):
        """Replaces element at index `i` with `new_heap_node`.

        1. If `new_heap_node == self.heap[i]`,
        then just replace `self.heap[i]` with `new_heap_node`.

        2. Else if `new_heap_node < self.heap[i]`,
        then push_up(index).

        3. Else `new_heap_node > self.heap[i]`,
        then call `self.heapify(i)`.

        **Time Complexity:** O(log<sub>2</sub> n)."""
        self.is_good_index(self.heap, i)

        current_node = self.heap[i]
        new_heap_node.index = current_node.index

        self.heap[i] = new_heap_node

        if new_heap_node > current_node:
            self.push_down(i)

        elif new_heap_node < current_node:
            self.push_up(i)
            
        return current_node
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ands.ds.MinHeap.MinHeap">MinHeap</a></li>
          <li>ands.ds.Heap.Heap</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ands.ds.MinHeap.MinHeap.NIE" class="name">var <span class="ident">NIE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, ls=[])</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.__init__" class="source">
    <pre><code>def __init__(self, ls=[]):
    Heap.__init__(self)
    self.heap = self._create_list_of_heap_nodes(ls)
    self._build_min_heap()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.add">
    <p>def <span class="ident">add</span>(</p><p>self, heap_node)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds a <code>heap_node</code> to this heap.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.add', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.add" class="source">
    <pre><code>def add(self, heap_node: HeapNode):
    """Adds a `heap_node` to this heap.
    **Time Complexity:** O(log<sub>2</sub> n)."""
    # Sets the current index of heap_node.
    # This index could change by a "push up" operation.
    heap_node.index = self.size()
    self.heap.append(heap_node)
    if self.size() > 1:
        self.push_up(self.size() - 1)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.clear">
    <p>def <span class="ident">clear</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Clears all nodes from this heap.
This mean that if you call <code>is_empty</code>,
it will return <code>True</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.clear', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.clear" class="source">
    <pre><code>def clear(self):
    """Clears all nodes from this heap.
    This mean that if you call `is_empty`,
    it will return `True`."""
    self.heap.clear()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.contains">
    <p>def <span class="ident">contains</span>(</p><p>self, heap_node)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns True, if heap_node is in the heaps.</p>
<p><strong>Time Complexity:</strong> O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.contains', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.contains" class="source">
    <pre><code>def contains(self, heap_node: HeapNode):
    """Returns True, if heap_node is in the heaps.
    **Time Complexity:** O(n)."""
    return self.search(heap_node) != -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.find_min">
    <p>def <span class="ident">find_min</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns (without removing) the smallest element in the heap.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.find_min', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.find_min" class="source">
    <pre><code>def find_min(self):
    """Returns (without removing) the smallest element in the heap.
    **Time Complexity:** O(1)."""
    if not self.is_empty():
        return self.heap[0]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.get">
    <p>def <span class="ident">get</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the list representing internally the heap.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.get', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.get" class="source">
    <pre><code>def get(self):
    """Returns the list representing internally the heap."""
    return self.heap
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.get_left_child_index">
    <p>def <span class="ident">get_left_child_index</span>(</p><p>ls, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the left child of the node at index <code>i</code>, if it exists.
Otherwise this function returns <code>None</code>.
If <code>i</code> is not a valid index for <code>ls</code>, an <code>IndexError</code> is raised.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.get_left_child_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.get_left_child_index" class="source">
    <pre><code>@staticmethod
def get_left_child_index(ls: list, i: int):
    """Returns the left child of the node at index `i`, if it exists.
    Otherwise this function returns `None`.
    If `i` is not a valid index for `ls`, an `IndexError` is raised."""
    Heap.is_good_index(ls, i)
    left = i * 2 + 1
    if Heap.is_good_index(ls, left, raise_error=False):
        return left
    else:
        return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.get_parent_index">
    <p>def <span class="ident">get_parent_index</span>(</p><p>ls, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the parent's position of the node at index <code>i</code>.
If <code>i = 0</code>, then <code>None</code> is returned, because the root has no parent.
If <code>i</code> is not a valid index for <code>ls</code>, an <code>IndexError</code> is raised.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.get_parent_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.get_parent_index" class="source">
    <pre><code>@staticmethod
def get_parent_index(ls: list, i: int):
    """Returns the parent's position of the node at index `i`.
    If `i = 0`, then `None` is returned, because the root has no parent.
    If `i` is not a valid index for `ls`, an `IndexError` is raised."""
    Heap.is_good_index(ls, i)
    if i == 0:
        return None
    else:
        return (i - 1) // 2
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.get_right_child_index">
    <p>def <span class="ident">get_right_child_index</span>(</p><p>ls, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the right child of the node at index <code>i</code>, if it exists.
Otherwise this function returns <code>None</code>.
If <code>i</code> is not a valid index for <code>ls</code>, an <code>IndexError</code> is raised.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.get_right_child_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.get_right_child_index" class="source">
    <pre><code>@staticmethod
def get_right_child_index(ls: list, i: int):
    """Returns the right child of the node at index `i`, if it exists.
    Otherwise this function returns `None`.
    If `i` is not a valid index for `ls`, an `IndexError` is raised."""
    Heap.is_good_index(ls, i)        
    right = i * 2 + 2
    if Heap.is_good_index(ls, right, raise_error=False):
        return right
    else:
        return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.heapify">
    <p>def <span class="ident">heapify</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Min-heapify this mean heap starting from index <code>i</code>.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.heapify', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.heapify" class="source">
    <pre><code>def heapify(self, i: int):
    """Min-heapify this mean heap starting from index `i`.
    **Time Complexity:** O(log<sub>2</sub> n)."""
    _min = i
    left = Heap.get_left_child_index(self.heap, i)
    right = Heap.get_right_child_index(self.heap, i)
    if left and self.heap[left] < self.heap[_min]:
        _min = left
    if right and self.heap[right] < self.heap[_min]:
        _min = right
    # One of the children of ls[i] was smaller than ls[i],
    # and we need to swap ls[i] with its smallest child ls[m].
    if _min != i:
        self.swap(_min, i)
        self.heapify(_min)
    return _min
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.is_empty">
    <p>def <span class="ident">is_empty</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns <code>True</code> if this heap is empty.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.is_empty', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.is_empty" class="source">
    <pre><code>def is_empty(self):
    """Returns `True` if this heap is empty."""
    return self.size() == 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.is_good_index">
    <p>def <span class="ident">is_good_index</span>(</p><p>ls, i, raise_error=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks if <code>i</code> is valid index for <code>ls</code>.</p>
<p>By default, if <code>i</code> is not a good index, a <code>IndexError</code> is raised.
If <code>raise_error</code> is set to <code>False</code>, then a <code>bool</code> value is returned.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.is_good_index', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.is_good_index" class="source">
    <pre><code>@staticmethod
def is_good_index(ls: list, i: int, raise_error=True):
    """Checks if `i` is valid index for `ls`.
    By default, if `i` is not a good index, a `IndexError` is raised.
    If `raise_error` is set to `False`, then a `bool` value is returned."""
    if i < 0 or i >= len(ls):
        if raise_error:
            raise IndexError("i is not a good index.")
        else:
            return False
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.merge">
    <p>def <span class="ident">merge</span>(</p><p>self, other_heap)</p>
    </div>
    

    
  
    <div class="desc"><p>Merges this heap with <code>other_heap</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.merge', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.merge" class="source">
    <pre><code>def merge(self, other_heap: Heap):
    """Merges this heap with `other_heap`."""
    self.heap += other_heap.get()
    def _merge_aux():
        """Updates the indices of all `HeapNode` objects."""
        for i, heap_node in enumerate(self.heap):
            heap_node.index = i
    _merge_aux()
    return self._build_min_heap()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.push_down">
    <p>def <span class="ident">push_down</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Calls self.heapify(i).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.push_down', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.push_down" class="source">
    <pre><code>def push_down(self, i: int):
    """Calls self.heapify(i)."""
    self.heapify(i)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.push_up">
    <p>def <span class="ident">push_up</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Pushes up the heap the node at index i.</p>
<p>Note that this operation only happens
if the node at index i is smaller than its parent.</p>
<p>This function is simpler than push_down or heapify,
because in this case we just need to compare
the current node's index with its parent's index.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.push_up', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.push_up" class="source">
    <pre><code>def push_up(self, i):
    """Pushes up the heap the node at index i.
    Note that this operation only happens
    if the node at index i is smaller than its parent.
    This function is simpler than push_down or heapify,
    because in this case we just need to compare
    the current node's index with its parent's index.
    **Time Complexity:** O(log<sub>2</sub> n)."""
    current_index = i
    p = MinHeap.get_parent_index(self.heap, i)
    # We need specifically to check if p is not None,
    # because it could be 0,
    # and the following if statement would not be executed (wrongly).
    if p is not None and self.heap[current_index] < self.heap[p]:
        current_index = p
        
    if current_index != i:
        self.swap(current_index, i)
        self.push_up(current_index)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.remove">
    <p>def <span class="ident">remove</span>(</p><p>self, i)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes the <code>HeapNode</code> object at index <code>i</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.remove', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.remove" class="source">
    <pre><code>def remove(self, i: int):
    """Removes the `HeapNode` object at index `i`. """
    raise NotImplementedError("'remove'" + Heap.NIE)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.remove_min">
    <p>def <span class="ident">remove_min</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes and returns the smallest element in this heap.</p>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n),
unless the list's pop operation is linear
also when popping the last element,
which would make this algorithm to have a time complexity O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.remove_min', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.remove_min" class="source">
    <pre><code>def remove_min(self):
    """Removes and returns the smallest element in this heap.
    **Time Complexity:** O(log<sub>2</sub> n),
    unless the list's pop operation is linear
    also when popping the last element,
    which would make this algorithm to have a time complexity O(n)."""
    if not self.is_empty():
        self.swap(0, self.size() - 1)
        min_element = self.heap.pop()
        
        if not self.is_empty():
            self.push_down(0)
            
        return min_element
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.replace">
    <p>def <span class="ident">replace</span>(</p><p>self, i, new_heap_node)</p>
    </div>
    

    
  
    <div class="desc"><p>Replaces element at index <code>i</code> with <code>new_heap_node</code>.</p>
<ol>
<li>
<p>If <code>new_heap_node == self.heap[i]</code>,
then just replace <code>self.heap[i]</code> with <code>new_heap_node</code>.</p>
</li>
<li>
<p>Else if <code>new_heap_node &lt; self.heap[i]</code>,
then push_up(index).</p>
</li>
<li>
<p>Else <code>new_heap_node &gt; self.heap[i]</code>,
then call <code>self.heapify(i)</code>.</p>
</li>
</ol>
<p><strong>Time Complexity:</strong> O(log<sub>2</sub> n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.replace', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.replace" class="source">
    <pre><code>def replace(self, i: int, new_heap_node: HeapNode):
    """Replaces element at index `i` with `new_heap_node`.
    1. If `new_heap_node == self.heap[i]`,
    then just replace `self.heap[i]` with `new_heap_node`.
    2. Else if `new_heap_node < self.heap[i]`,
    then push_up(index).
    3. Else `new_heap_node > self.heap[i]`,
    then call `self.heapify(i)`.
    **Time Complexity:** O(log<sub>2</sub> n)."""
    self.is_good_index(self.heap, i)
    current_node = self.heap[i]
    new_heap_node.index = current_node.index
    self.heap[i] = new_heap_node
    if new_heap_node > current_node:
        self.push_down(i)
    elif new_heap_node < current_node:
        self.push_up(i)
        
    return current_node
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.search">
    <p>def <span class="ident">search</span>(</p><p>self, heap_node)</p>
    </div>
    

    
  
    <div class="desc"><p>Searches for heap_node in this heap,
and if present, returns its index, otherwise returns -1.</p>
<p><strong>Time Complexity:</strong> O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.search', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.search" class="source">
    <pre><code>def search(self, heap_node: HeapNode):
    """Searches for heap_node in this heap,
    and if present, returns its index, otherwise returns -1.
    **Time Complexity:** O(n)."""
    for i, node in enumerate(self.heap):
        if node == heap_node:
            return i
    return -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.search_by_value">
    <p>def <span class="ident">search_by_value</span>(</p><p>self, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the index of the HeapNode with value=value.
-1 is returned if no such a HeapNode exists.</p>
<p><strong>Time Complexity:</strong> O(n).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.search_by_value', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.search_by_value" class="source">
    <pre><code>def search_by_value(self, value: object):
    """Returns the index of the HeapNode with value=value.
    -1 is returned if no such a HeapNode exists.
    **Time Complexity:** O(n)."""
    for i, node in enumerate(self.heap):
        if node.value == value:
            return i
    return -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.show">
    <p>def <span class="ident">show</span>(</p><p>self, total_width=36, fill=&#39; &#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Pretty-prints this heap.</p>
<p>To increase/decrease the horizontal space between nodes,
just increase/decrease the float number h_space.</p>
<p>To increase/decrease the vertical space between nodes,
just increase/decrease the integer number v_space.
Note that v_space must be an integer.</p>
<p>To change the length of the line under the heap,
you can simply change the line_length variable.</p>
<p>Adapted for Python 3 from:
<a href="http://pymotw.com/2/heapq/">http://pymotw.com/2/heapq/</a>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.show', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.show" class="source">
    <pre><code>def show(self, total_width=36, fill=" "):
    """Pretty-prints this heap.
    To increase/decrease the horizontal space between nodes,
    just increase/decrease the float number h_space.
    To increase/decrease the vertical space between nodes,
    just increase/decrease the integer number v_space.
    Note that v_space must be an integer.
    To change the length of the line under the heap,
    you can simply change the line_length variable.
    Adapted for Python 3 from:
    [http://pymotw.com/2/heapq/](http://pymotw.com/2/heapq/)."""
    if self.heap:
        from io import StringIO
        import math
        output = StringIO()
        last_row = -1
        h_space = 1.5  # float
        v_space = 2    # int
        for i, heap_node in enumerate(self.heap):
            if i:
                row = int(math.floor(math.log(i + 1, 2)))
            else:
                row = 0
            if row != last_row:
                output.write("\n"*v_space)
            columns = 2 ** row
            column_width = int(math.floor((total_width * h_space) / columns))
            output.write(str(heap_node).center(column_width, fill))
            last_row = row
        print(output.getvalue())
        line_length = total_width + 15  # int
        print('-' * line_length)
    else:
        print("Nothing to show: heap is empty.")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.size">
    <p>def <span class="ident">size</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the size of this heaps.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.size', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.size" class="source">
    <pre><code>def size(self):
    """Returns the size of this heaps."""
    return len(self.heap)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ands.ds.MinHeap.MinHeap.swap">
    <p>def <span class="ident">swap</span>(</p><p>self, i, j)</p>
    </div>
    

    
  
    <div class="desc"><p>Swaps <code>HeapNode</code> objects at indexes <code>i</code> and <code>j</code>,
and updates their new index field's value.</p>
<p><strong>Time Complexity:</strong> O(1).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ands.ds.MinHeap.MinHeap.swap', this);">Show source &equiv;</a></p>
  <div id="source-ands.ds.MinHeap.MinHeap.swap" class="source">
    <pre><code>def swap(self, i: int, j: int):
    """Swaps `HeapNode` objects at indexes `i` and `j`,
    and updates their new index field's value.
    **Time Complexity:** O(1)."""
    self.is_good_index(self.heap, i)
    self.is_good_index(self.heap, j)
    # Updates the index field of each HeapNode.
    # This is useful for example when search for a Node's position
    # which can then be done therefore in constant time.
    self.heap[i].index = j
    self.heap[j].index = i
    self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ands.ds.MinHeap.MinHeap.heap" class="name">var <span class="ident">heap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
